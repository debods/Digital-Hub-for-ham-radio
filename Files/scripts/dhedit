#!/usr/bin/env bash

: <<'END'
dhedit
DigiHub installation editor

Version 1.0a

Steve de Bode - KQ4ZCI - December 2025

Input:	non
Output: none - interactive
END

### VARIABLES ###
colr='\e[31m'; colb='\033[34m'; ncol='\e[0m'
DigiHubHome="$HomePath/DigiHub"
ScriptPath="$DigiHubHome/scripts"
venv_dir="$DigiHubHome/.digihub-venv"
PythonPath="$DigiHubHome/pyscripts"

### FUNCTIONS ###

# Required values
PromptReq() {
 local var_name=$1 prompt=$2 value
 while [[ -z $value ]]; do
  read -rp "$prompt" value
 done
 printf -v "$var_name" '%s' "$value"
}

# Optional values
PromptOpt() {
 local var_name=$1 prompt=$2 value
 read -rp "$prompt" value
 printf -v "$var_name" '%s' "$value"
}

# Set variables to "Unknown" if they are empty/whitespace
SetUnknownIfEmpty() {
 local v
 for v in "$@"; do
  [[ -z ${!v//[[:space:]]/} ]] && printf -v "$v" '%s' "Unknown"
 done
}

# Editable prompt
# Usage: PromptEdit var_name "Prompt: " required(0|1)
PromptEdit() {
 local var_name=$1 prompt=$2 required=${3:-0}
 local current value

 while :; do
  current=${!var_name}

  if [[ -n $current ]]; then
   read -rp "${prompt} [${current}]: " value
  else
   read -rp "${prompt}: " value
  fi

  # Replace if user typed something
  if [[ -n $value ]]; then
   printf -v "$var_name" '%s' "$value"
   return 0
  fi

  # Keep existing if Enter and already set
  if [[ -n $current ]]; then
   return 0
  fi

  # Allow empty if not required
  if (( required == 0 )); then
   printf -v "$var_name" '%s' ""
   return 0
  fi

  printf 'This field is required.\n' >&2
 done
}

# Review & edit
ReviewAndEdit() {
 local choice

 while true; do
  printf '\n================ REVIEW =================\n'
  printf ' 1) Callsign:   %s\n' "${callsign^^}"
  printf ' 2) Latitude:   %s\n' "$lat"
  printf ' 3) Longitude:  %s\n' "$lon"
  printf ' 4) Grid:       %s\n' "$grid"
  printf ' 5) Class:      %s\n' "$class"
  printf ' 6) Expiry:     %s\n' "$expiry"
  printf ' 7) Lic Status: %s\n' "$licstat"
  printf ' 8) Forename:   %s\n' "$forename"
  printf ' 9) Initial:    %s\n' "$initial"
  printf '10) Surname:    %s\n' "$surname"
  printf '11) Suffix:     %s\n' "$suffix"
  printf '12) Street:     %s\n' "$street"
  printf '13) Town/City:  %s\n' "$town"
  printf '14) State:      %s\n' "$state"
  printf '15) ZIP/Postal: %s\n' "$zip"
  printf '16) Country:    %s\n' "$country"
  printf '========================================\n'

  read -r -p $'\nEnter a number to edit (1-16), or press Enter to accept: ' choice
  [[ -z $choice ]] && return 0

  case "$choice" in
   1) PromptEdit callsign "Callsign" 1 ;;
   2) PromptEdit lat "Latitude (-90..90)" 1 ;;
   3) PromptEdit lon "Longitude (-180..180)" 1 ;;
   5) PromptEdit class "Class" 0 ;;
   6) PromptEdit expiry "Expiry" 0 ;;
   7) PromptEdit licstat "License Status" 0 ;;
   8) PromptEdit forename "Forename" 0 ;;
   9) PromptEdit initial "Initial" 0 ;;
  10) PromptEdit surname "Surname" 0 ;;
  11) PromptEdit suffix "Suffix" 0 ;;
  12) PromptEdit street "Street" 0 ;;
  13) PromptEdit town "Town/City" 0 ;;
  14) PromptEdit state "State/Province" 0 ;;
  15) PromptEdit zip "ZIP/Postal Code" 0 ;;
  16) PromptEdit country "Country" 0 ;;
   4)
    printf 'Grid is derived from Latitude/Longitude. Edit 2 or 3 to change it.\n' ;;
   *)
    printf 'Invalid selection.\n' >&2 ;;
  esac

  # If lat/lon changed (or user asked), validate and regenerate grid
  if [[ $choice == 2 || $choice == 3 ]]; then
   local max_tries=5 tries=0 rc
   while true; do
    python3 "$InstallPath"/Files/pyscripts/validcoords.py "$lat" "$lon"
    rc=$?
    case "$rc" in
     0)
      grid="$(python3 "$InstallPath"/Files/pyscripts/hamgrid.py "$lat" "$lon")"
      if [[ -z $grid ]]; then echo "Error: hamgrid.py produced no output."; exit 4; fi
      break
      ;;
     1)
      ((tries++))
      if (( tries >= max_tries )); then
       printf '\nToo many invalid attempts, aborting installation.\n'
       exit 1
      fi
      printf '\nInvalid latitude/longitude. Please try again:\n'
      PromptEdit lat "Latitude (-90..90)" 1
      PromptEdit lon "Longitude (-180..180)" 1
      ;;
     2) printf 'Error: validcoords.py usage or internal error.\n'; exit 2 ;;
     *) printf 'Error: validcoords.py returned unexpected exit code %s.\n' "$rc"; exit 3 ;;
    esac
   done
  fi
 done
}

BuildFullName() {
  local parts=()

  # Only include if non-empty AND not "Unknown"
  [[ -n "$forename" && "$forename" != "Unknown" ]] && parts+=("$forename")
  [[ -n "$initial"  && "$initial"  != "Unknown" ]] && parts+=("$initial")
  [[ -n "$surname"  && "$surname"  != "Unknown" ]] && parts+=("$surname")

  # Suffix is special: append to the end (no extra space issues)
  if [[ -n "$suffix" && "$suffix" != "Unknown" ]]; then
    parts+=("$suffix")
  fi

  if ((${#parts[@]} == 0)); then
    fullname="Unknown"
  else
    # Join with single spaces
    fullname="${parts[*]}"
  fi
}

BuildAddress() {
  local parts=()

  [[ -n "$street" && "$street" != "Unknown" ]] && parts+=("$street")
  [[ -n "$town"   && "$town"   != "Unknown" ]] && parts+=("$town")

  # Combine state + ZIP if either exists
  local statezip=""
  [[ -n "$state" && "$state" != "Unknown" ]] && statezip="$state"
  [[ -n "$zip"   && "$zip"   != "Unknown" ]] && statezip="${statezip:+$statezip }$zip"
  [[ -n "$statezip" ]] && parts+=("$statezip")

  [[ -n "$country" && "$country" != "Unknown" ]] && parts+=("$country")

  if ((${#parts[@]} == 0)); then
    address="Unknown"
  else
    address=$(IFS=', '; echo "${parts[*]}")
  fi
}

# y/n; return 0 for yes.
YnCont() {
 local prompt=${1:-"Continue (y/N)? "} reply
 while :; do
  read -n1 -rp "$prompt" reply
  printf '\n'
  case $reply in
   [Yy]) return 0 ;;
   [Nn]) return 1 ;;
   *) printf '%s\n' 'Please select (y/N): ' ;;
  esac
 done
}
