#!/usr/bin/env bash


set -euo pipefail

trim() {
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}

parse_coord() {
  local kind="$1"; shift
  local raw="$*"
  raw="$(trim "$raw")"

  awk -v kind="$kind" -v s="$raw" '
    function abs(x){ return x<0 ? -x : x }
    BEGIN {
      s=toupper(s)

      hemi=""
      if (s~/S/) hemi="S"
      if (s~/W/) hemi="W"
      if (s~/N/) hemi="N"
      if (s~/E/) hemi="E"

      gsub(/[°ºD]/," ",s)
      gsub(/[′’´\047]/," ",s)
      gsub(/[″“”\042]/," ",s)
      gsub(/,/," ",s)
      gsub(/[A-Z]/," ",s)
      gsub(/[[:space:]]+/," ",s)
      sub(/^ /,"",s); sub(/ $/,"",s)

      n=split(s,a," ")
      if (n<1) exit 1

      for(i=1;i<=n;i++)
        if(a[i]!~/^[+-]?([0-9]+(\.[0-9]+)?|\.[0-9]+)$/) exit 1

      deg=a[1]+0
      min=(n>=2?a[2]+0:0)
      sec=(n>=3?a[3]+0:0)

      if(n==1)
        val=deg
      else if(n==2)
        val=(deg<0?-1:1)*(abs(deg)+(min/60))
      else
        val=(deg<0?-1:1)*(abs(deg)+(min/60)+(sec/3600))

      if(hemi=="S"||hemi=="W") val=-abs(val)
      if(hemi=="N"||hemi=="E") val= abs(val)

      if(kind=="lat" && (val<-90||val>90)) exit 1
      if(kind=="lon" && (val<-180||val>180)) exit 1

      printf "%.6f",val
    }
  ' || return 1
}

prompt_coord() {
  local kind="$1" label="$2" current="${3:-}"
  local raw="" dec=""

  while true; do
    if [[ -n "$current" ]]; then
      printf '%s [%s]: ' "$label" "$current" >/dev/tty
    else
      printf '%s: ' "$label" >/dev/tty
    fi

    # Read from the terminal explicitly (so this still works if stdout is captured)
    IFS= read -r raw </dev/tty
    raw="$(trim "${raw:-$current}")"

    if dec="$(parse_coord "$kind" "$raw")"; then
      # ONLY the decimal value goes to stdout (captured by $(...))
      printf '%s' "$dec"
      return 0
    fi

    if [ "$kind" == "lat" ]; then coordtype="Latitude"; elif [ "$kind" == "lon" ]; then coordtype="Longitude"; fi
    printf '%s\n' "The ${coordtype} coordinate entered is not valid." >/dev/tty
    current="$raw"
  done
}

main() {

  local callsign lat lon grid ans edit

  printf '\n%s' 'Plaese enter the callsign: ' >/dev/tty
  IFS= read -r callsign </dev/tty
  callsign="$(trim "$callsign")"

  lat="$(prompt_coord lat 'Latitude (decimal / DM / DMS + N/S)')"
  lon="$(prompt_coord lon 'Longitude (decimal / DM / DMS + E/W)')"

  while true; do
    grid="$("$DigiHubPy/hamgrid.py" "$lat" "$lon")"

    printf '\n' >/dev/tty 
    printf '%s\n' 'The information entered is:' >/dev/tty
    printf '\n' >/dev/tty
    printf '  Callsign:          %s\n' "$callsign" >/dev/tty
    printf '  Latitude:          %s\n' "$lat" >/dev/tty
    printf '  Longitude:         %s\n' "$lon" >/dev/tty
    printf '  Grid (calculated): %s\n' "$grid" >/dev/tty
    printf '\n' >/dev/tty
    printf '%s' 'Is this correct (y)es (n)o - you can edit the information or (q)uit: ' >/dev/tty
    IFS= read -r ans </dev/tty

    case "$ans" in
      y|Y)
        # Final CSV goes to stdout
        printf '%s,%s,%s,%s\n' "$callsign" "$lat" "$lon" "$grid"
        exit 0
        ;;
      n|N)
        # No - Edit Information
        printf '\n' >/dev/tty
        printf '%s' 'Please select the information to edit (c)callsign, (l)atitude, (g) longitude or (a)ll: ' >/dev/tty
        IFS= read -r edit </dev/tty
        case "$edit" in
          c|C)
            printf '\n' >/dev/tty
            printf '%s' 'Callsign: ' >/dev/tty
            IFS= read -r callsign </dev/tty
            callsign="$(trim "$callsign")"
            ;;
          l|L)
            printf '\n' >/dev/tty
            lat="$(prompt_coord lat 'Latitude' "$lat")"
            ;;
          g|G)
            printf '\n' >/dev/tty
            lon="$(prompt_coord lon 'Longitude' "$lon")"
            ;;
          a|A)
            printf '\n' >/dev/tty
            printf '%s' 'Callsign: ' >/dev/tty
            IFS= read -r callsign </dev/tty
            callsign="$(trim "$callsign")"
            lat="$(prompt_coord lat 'Latitude')"
            lon="$(prompt_coord lon 'Longitude')"
            ;;
        esac
        ;;
      q|Q)
        exit 1
        ;;
    esac
  done
}

main "$@"
